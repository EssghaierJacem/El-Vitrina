import google.generativeai as genai
import os
import json
import re
import argparse
from PIL import Image
from typing import Dict, Optional, List, Union

# Configuration de l'API
GOOGLE_API_KEY = "AIzaSyAA-RKy40sxGwZoRX7OvuW5d6T04czBY6U"
genai.configure(api_key=GOOGLE_API_KEY)

# Initialisation du modÃ¨le Gemini Pro Vision
model = genai.GenerativeModel('gemini-1.5-flash')

# Define available product categories to match with the Java backend
PRODUCT_CATEGORIES = [
    "HANDMADE_JEWELRY",
    "POTTERY_CERAMICS",
    "TEXTILES_FABRICS",
    "ART_PAINTINGS",
    "HOME_DECOR",
    "CLOTHING_ACCESSORIES",
    "ECO_FRIENDLY",
    "LOCAL_FOODS",
    "HEALTH_WELLNESS",
    "BOOKS_STATIONERY",
    "TOYS_GAMES",
    "VINTAGE_ANTIQUES",
    "DIGITAL_PRODUCTS",
    "CRAFTS_DIY",
    "PET_SUPPLIES"
]

# Mapping of category display names for better matching
CATEGORY_DISPLAY_NAMES = {
    "HANDMADE_JEWELRY": "Handmade Jewelry",
    "POTTERY_CERAMICS": "Pottery & Ceramics",
    "TEXTILES_FABRICS": "Textiles & Fabrics",
    "ART_PAINTINGS": "Art & Paintings",
    "HOME_DECOR": "Home Decor",
    "CLOTHING_ACCESSORIES": "Clothing & Accessories",
    "ECO_FRIENDLY": "Eco-Friendly Products",
    "LOCAL_FOODS": "Local Foods & Beverages",
    "HEALTH_WELLNESS": "Health & Wellness",
    "BOOKS_STATIONERY": "Books & Stationery",
    "TOYS_GAMES": "Toys & Games",
    "VINTAGE_ANTIQUES": "Vintage & Antiques",
    "DIGITAL_PRODUCTS": "Digital Products",
    "CRAFTS_DIY": "Crafts & DIY Kits",
    "PET_SUPPLIES": "Pet Supplies"
}

def analyze_image(image_path: str) -> Optional[Dict[str, Union[str, List[str]]]]:
    """
    Analyzes an image using Gemini Pro Vision to identify its content
    and suggest relevant keywords.

    Args:
        image_path (str): Path to the image file to analyze.

    Returns:
        Optional[Dict[str, Union[str, List[str]]]]: Dictionary containing the analysis results
        or None if an error occurs.
    """
    try:
        # Verify file exists
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Image file '{image_path}' does not exist.")

        # Open and validate the image
        img = Image.open(image_path)
        
        # Create prompt for analysis
        categories_list = "\n".join([f"- {CATEGORY_DISPLAY_NAMES[cat]}" for cat in PRODUCT_CATEGORIES])
        
        prompt = f"""
        Analyze this product image in detail and provide the following information IN ENGLISH ONLY:
        
        1. Category: Choose the MOST APPROPRIATE category from this list that matches the product:
        {categories_list}
        
        2. Keywords: List 5-8 relevant keywords separated by commas that would be useful for searching for this product.
        
        3. Description: Write a concise, informative product description (50-100 words) highlighting the key features.
        """

        # Generate response
        response = model.generate_content([prompt, img])
        response.resolve()

        if not response.parts:
            raise ValueError("No response was generated by the model.")

        # Extract raw response
        raw_response = response.parts[0].text
        
        # Parse results
        parsed_results = parse_results(raw_response)
        
        # Map the category to one of the predefined categories
        parsed_results["category"] = map_to_predefined_category(parsed_results["category"])
        
        # Build final result
        return {
            "raw_response": raw_response,
            **parsed_results
        }

    except Exception as e:
        print(f"Error analyzing image: {str(e)}")
        return None

def map_to_predefined_category(suggested_category: str) -> str:
    """
    Maps the suggested category to one of the predefined categories.
    
    Args:
        suggested_category (str): The category suggested by the AI.
        
    Returns:
        str: The mapped predefined category.
    """
    if not suggested_category:
        return PRODUCT_CATEGORIES[4]  # Default to HOME_DECOR if no category is suggested
    
    # First, try direct match with display names
    for category, display_name in CATEGORY_DISPLAY_NAMES.items():
        if suggested_category.lower() == display_name.lower():
            return category
    
    # If no direct match, look for partial matches
    suggested_lower = suggested_category.lower()
    best_category = None
    best_match_score = 0
    
    for category, display_name in CATEGORY_DISPLAY_NAMES.items():
        display_lower = display_name.lower()
        
        # Check if suggested category contains the display name or vice versa
        if suggested_lower in display_lower or display_lower in suggested_lower:
            # Calculate a simple match score based on length of overlap
            score = len(set(suggested_lower.split()) & set(display_lower.split()))
            if score > best_match_score:
                best_match_score = score
                best_category = category
    
    # If we found a decent match
    if best_category:
        return best_category
    
    # Fallback: check for specific keywords
    keywords = {
        "jewelry": "HANDMADE_JEWELRY",
        "necklace": "HANDMADE_JEWELRY",
        "bracelet": "HANDMADE_JEWELRY",
        "earring": "HANDMADE_JEWELRY",
        "pottery": "POTTERY_CERAMICS",
        "ceramic": "POTTERY_CERAMICS",
        "clay": "POTTERY_CERAMICS",
        "fabric": "TEXTILES_FABRICS",
        "textile": "TEXTILES_FABRICS",
        "cloth": "TEXTILES_FABRICS",
        "painting": "ART_PAINTINGS",
        "art": "ART_PAINTINGS",
        "canvas": "ART_PAINTINGS",
        "decor": "HOME_DECOR",
        "decoration": "HOME_DECOR",
        "furniture": "HOME_DECOR",
        "clothing": "CLOTHING_ACCESSORIES",
        "accessory": "CLOTHING_ACCESSORIES",
        "wear": "CLOTHING_ACCESSORIES",
        "eco": "ECO_FRIENDLY",
        "sustainable": "ECO_FRIENDLY",
        "green": "ECO_FRIENDLY",
        "food": "LOCAL_FOODS",
        "beverage": "LOCAL_FOODS",
        "drink": "LOCAL_FOODS",
        "health": "HEALTH_WELLNESS",
        "wellness": "HEALTH_WELLNESS",
        "book": "BOOKS_STATIONERY",
        "stationery": "BOOKS_STATIONERY",
        "paper": "BOOKS_STATIONERY",
        "toy": "TOYS_GAMES",
        "game": "TOYS_GAMES",
        "play": "TOYS_GAMES",
        "vintage": "VINTAGE_ANTIQUES",
        "antique": "VINTAGE_ANTIQUES",
        "old": "VINTAGE_ANTIQUES",
        "digital": "DIGITAL_PRODUCTS",
        "software": "DIGITAL_PRODUCTS",
        "download": "DIGITAL_PRODUCTS",
        "craft": "CRAFTS_DIY",
        "diy": "CRAFTS_DIY",
        "kit": "CRAFTS_DIY",
        "pet": "PET_SUPPLIES",
        "dog": "PET_SUPPLIES",
        "cat": "PET_SUPPLIES",
    }
    
    for keyword, category in keywords.items():
        if keyword in suggested_lower:
            return category
    
    # Default fallback
    return PRODUCT_CATEGORIES[4]  # Default to HOME_DECOR

def parse_results(raw_response: str) -> Dict[str, Union[str, List[str]]]:
    """
    Parses the raw response from Gemini to extract structured information.

    Args:
        raw_response (str): Raw model response.

    Returns:
        Dict[str, Union[str, List[str]]]: Dictionary containing structured
        information (category, keywords, description).
    """
    result = {
        "category": "",
        "keywords": [],
        "description": ""
    }

    try:
        # Extract category
        category_match = re.search(r"Category\s*:?\s*([^\n]+)", raw_response)
        if category_match:
            result["category"] = category_match.group(1).strip()

        # Extract keywords
        keywords_match = re.search(r"Keywords\s*:?\s*([^\n]+)", raw_response)
        if keywords_match:
            keywords = keywords_match.group(1).strip()
            result["keywords"] = [k.strip() for k in keywords.split(',')]

        # Extract description
        description_match = re.search(r"Description\s*:?\s*([^\n]+(?:\n[^\n]+)*)", raw_response)
        if description_match:
            result["description"] = description_match.group(1).strip()

    except Exception as e:
        print(f"Error parsing results: {str(e)}")

    return result

def save_results(results: Dict[str, Union[str, List[str]]], output_file: str) -> None:
    """
    Saves analysis results to a JSON file.

    Args:
        results (Dict[str, Union[str, List[str]]]): Analysis results.
        output_file (str): Path to the output file.
    """
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2)
        print(f"Results saved to {output_file}")
    except Exception as e:
        print(f"Error saving results: {str(e)}")

def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description='Analyze a product image and extract relevant information')
    parser.add_argument('--image', type=str, required=True, help='Path to the image to analyze')
    parser.add_argument('--output', type=str, help='Path to the output JSON file (optional)')
    
    args = parser.parse_args()
    
    # Analyze the image
    results = analyze_image(args.image)
    
    if results:
        if args.output:
            save_results(results, args.output)
        
        # Print results to stdout as JSON for Java process to read
        print(json.dumps(results, ensure_ascii=False))
        return 0
    else:
        print(json.dumps({"error": "Image analysis failed"}))
        return 1

if __name__ == "__main__":
    exit_code = main()
    exit(exit_code)